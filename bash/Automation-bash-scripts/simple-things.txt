#!/bin/bash

echo "Input what you want to do:
1. nothing
2. update packages"
read
if [[ "$REPLY" -eq 2 ]];
   then sudo apt update;
   else echo "agree with you!" 
fi
------------------------------------

#!/bin/bash

read -p "Input your name please:" $1
if [[ $REPLY == "Dan" ]] || [[ $REPLY == "Vladimir" ]]
   then echo "Hello, $REPLY!";
   else echo "Woops, not found such user" 
fi
---------------------------
#!/bin/bash

if [[ $1 == "John" ]];
   then echo "Hello, $1!";
   else echo "Woops, not found such user" 
fi
------------------------------------

#!/bin/bash

# Matching arguments to regex positive integer between 1 and 100:
for arg in $@
  do
    if [[ ! $arg =~ ^[1-9][0-9]?$|^100$ ]]; then
      echo "Input is wrong. Only positive integer between 1 and 100. Restart script."; exit
    fi
  done

# or this way:
#if [[ ! $1 =~ ^[1-9][0-9]?$|^100$ ]] || [[ ! $2 =~ ^[1-9][0-9]?$|^100$ ]] || [[ ! $3 =~ ^[1-9][0-9]?$|^100$ ]];
#   then echo "Input is wrong. Restart script."; exit;
#fi

# Checking triangle type:
if [[ $1 -ne $2 ]] && [[ $1 -ne $3 ]] && [[ $2 -ne $3 ]];
   then echo "SCALENE";
elif [[ $1 -eq $2 ]] && [[ $1 -eq $3 ]] && [[ $2 -eq $3 ]];
   then echo "EQUILATERAL";
   else echo "ISOSCELES";
fi
------------------------------------

if [[ $(find . -name "$1" -size -1025c) ]]; then
  echo "OK"
else
  echo "FAIL"
fi

------------------------------------------

#!/bin/bash

# The script should be named loops.sh.
# The script must accept a single argument: a string.
# The script should produce the reversed version of the input string.
# It must swap the case of each letter in the string,
# i.e., convert uppercase letters to lowercase and vice versa.
# Check:
# ./loops.sh "Hello Bash"  
# Output: HSAb OLLEh

s="$1"
string=${#s}
for (( i=$string-1; i>=0; i-- )); do
  revstr=$revstr${s:$i:1}
  res=$(echo $revstr | tr 'a-zA-Z' 'A-Za-z')
done
echo $res

------------------------------------------

#!/bin/bash
# Construct a program that accepts a digit (indicating the desired 
# number of directories up to 26) as input. 
# The program should then generate these directories 
# within the current working path using the naming scheme dir_<[a-z]>.
# For example:
# ./listScript.sh 5
# Result: 5 directories established: dir_a, dir_b, dir_c, dir_d, dir_e
# ./listScript.sh 1
# Result: 1 directory established: dir_a

n=$1
if [ $n -gt 26 ]; 
  then echo "Input is wrong. Restart script."
  exit
fi 
a=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
for (( i=0; i<$n; i++ ))
do
  mkdir dir_${a[$i]}
donei

----------------------------------

# convert temperatures between Celsius and Kelvin scales

t=$(echo $1 | sed 's/[cCkK]//g')
case $1 in
    [0-9]*[^cCkK])
        echo "Scale is except. Try again."
        exit 1
    ;;
    -[0-9]*[^cCkK])
        echo "Scale is except. Try again."
        exit 1
    ;;
    [0-9]*[cC])
        [[ $t -lt -273 ]] 2> /dev/null && echo "Min value of absolute zero is -273C. Try again." && exit 1
        echo "$((${1%[a-zA-Z]} + 273))K"
    ;;
    -[0-9]*[cC])
        [[ $t -lt -273 ]] 2> /dev/null && echo "Min value of absolute zero is -273C. Try again." && exit 1
        echo "$((${1%[a-zA-Z]} + 273))K"
    ;;
    [0-9]*[kK])
        [[ $t -lt -273 ]] 2> /dev/null && echo "Min value of absolute zero is -273C. Try again." && exit 1
        echo "$((${1%[a-zA-Z]} - 273))C"
    ;;
    -[0-9]*[kK])
        [[ $t -lt -273 ]] 2> /dev/null && echo "Min value of absolute zero is -273C. Try again." && exit 1
        echo "$((${1%[a-zA-Z]} - 273))C"
    ;;
     *)
        echo "Input is not numerical. Try again."
        exit 1
esac

-------------------------------------

# Read a string
read -p "Enter an IP address: " input

# Define the regular expression
regex='([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})'

# Check if the input matches the regular expression
if [[ "$input" =~ $regex ]]; then
  # Extract the matched IP address
  ip_address=${BASH_REMATCH[1]}

  # Print the IP address
  echo "IP address: $ip_address"
else
  echo "Input is not a valid IP address"
fi

--------------------------------------------

#!/bin/bash

# Read the user's input
read -p "Enter a password: " password

# Define the regular expression to validate the password
regex='^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$'

# Check if the password is valid
if [[ "$password" =~ $regex ]]; then
  echo "Password is valid"
else
  echo "Password is invalid"
fi















