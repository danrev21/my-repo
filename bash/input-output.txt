
grep dan /etc/* > good.txt       # write only good and output bad
grep dan /etc/* 2> nogood.txt   # write only bad and output good
grep dan /etc/* > good.txt 2> nogood.txt   # write output to separate folders
grep dan /etc/* &> all_outputs.txt
# use >> to add output into file

grep dan /etc/* 2> /dev/null  # output only good output

sort file.txt >> file.txt   # if use > then delete file.txt

можно передать содержимое файла в другой терминал:
tty - узнаем имя терминал куда передать содержимое
cat file > /dev/pts/1

-----

#!/bin/bash
echo "This is a standard output" > stdout.txt
echo "This is an error message" >&2 > stderr.txt
------------------------------------
#!/usr/bin/env bash
echo "This is a standard output that will be silenced" > /dev/null
echo "This is an error message that will be silenced" >&2 > /dev/null

-------------------------------------------------------
command << delimiter
document
delimiter

  Здесь оболочка интерпретирует оператор << как инструкцию читать ввод, пока не найдет строку, содержащую указанный разделитель. Все входные строки до строки, содержащей разделитель, затем подаются на стандартный ввод команды.
  Разделитель сообщает оболочке, что здесь документ завершен. Без него оболочка продолжает читать ввод бесконечно. Разделителем должно быть одно слово, не содержащее пробелов и знаков табуляции.
-------------------------------------------------------
  
# Ниже приведен ввод команды wc -l для подсчета общего количества строк:
wc -l << EOF
1111111 
2222222
3333333
EOF

# в файл
cat > Dockerfile << EOF
FROM nginx
EXPOSE 80
RUN echo "<html><body>Student: Billy</body></html>" > /usr/share/nginx/html/index.html
CMD nginx -g 'daemon off;'
EOF

# It's more concise, plus unlike the redirect operator it can be combined with sudo if you need to write to files with root permissions:
tee newfile <<EOF
line 1
line 2
line 3
EOF

-----------------------------------------------------
# нужно будет выполнить команду, но вы не хотите, чтобы вывод отображался на экране:
ls -jj 2> /dev/null 

-----------------------------------------------------
echo "This is a standard output" > stdout.txt
echo "This is an error message" >&2 > stderr.txt

------------------------------------
echo "This is a standard output that will be silenced" > /dev/null
echo "This is an error message that will be silenced" >&2 > /dev/null

------------------------------------
[ -f "data.txt" ] && echo "File data.txt found!"
cp data.txt backup.txt 2> /dev/null
[ -f "data.txt" ] || echo "File data.txt not found!"


# if [ ! -f data.txt ]
# then
#     echo "File does not exist in Bash"
# else
#     echo "File data.txt found!"
#     cp data.txt backup.txt 2> /dev/null
# fi

------------------------------------------------------
# To overwrite an existing file (or write to a new file) that you own, substituting variable references inside the heredoc:

cat << EOF > /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, with the variable contents substituted.
EOF

# To append an existing file (or write to a new file) that you own, substituting variable references inside the heredoc:

cat << FOE >> /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, with the variable contents substituted.
FOE

# To overwrite an existing file (or write to a new file) that you own, with the literal contents of the heredoc:

cat << 'END_OF_FILE' > /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, without the variable contents substituted.
END_OF_FILE
To append an existing file (or write to a new file) that you own, with the literal contents of the heredoc:

cat << 'eof' >> /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, without the variable contents substituted.
eof

# To overwrite an existing file (or write to a new file) owned by root, substituting variable references inside the heredoc:

cat << until_it_ends | sudo tee /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, with the variable contents substituted.
until_it_ends

# To append an existing file (or write to a new file) owned by user=foo, with the literal contents of the heredoc:

cat << 'Screw_you_Foo' | sudo -u foo tee -a /path/to/your/file
This line will write to the file.
${THIS} will also write to the file, without the variable contents substituted.
Screw_you_Foo

























